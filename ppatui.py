#!/usr/bin/env python
# -*- coding: utf-8 -*-

# a preprocessor that consumes json5 files to produce c source files for
# atomtree atui.
# ppatui.py input.json5 output.c

import sys
import copy
import json5


def enum_to_h(atui_data:dict):
	assert(atui_data["class"] == "enum")
	enum_file_start = """\
/* autogenerated with ppatui.py. Do not edit */

#ifndef ATUI_ENUMS_H
#define ATUI_ENUMS_H

"""
	enum_file_end = "\n#endif\n"
	enum_template = """
static_assert(%u <= 255); // uint8_t limits
static const struct atui_enum PPATUI_ENUM_NAME(%s) = {
	.name = u8"%s",
	.num_entries = %u,
	.enum_array = (const struct atui_enum_entry[]) {
%s\
	},
};
"""
	enum_entry_template = "\t\t{.name = u8\"%s\", .val = %s},\n"

	out_text = enum_file_start
	enum_entries = ""
	for enum in atui_data["enums"]:
		enum_entries = ""
		for entry in enum["constants"]:
			enum_entries += enum_entry_template % (entry, entry)
		out_text += enum_template % (
			len(enum["constants"]), # assert
			enum["name"], enum["name"], len(enum["constants"]), enum_entries
		)
	return out_text + enum_file_end



class atui_leaf:
	default_type:str
	access:str
	name:str
	display:str
	fancy:str
	fancy_data:None #dict, str, list
	description:dict
	lo:str
	hi:str

	def copy(self):
		return copy.copy(self)

	def __init__(self, leaf:dict):
		leafkeys = set(leaf)

		if "default_type" in leafkeys:
			self.default_type = leaf["default_type"]
		else:
			self.default_type = None
		if "access" in leafkeys:
			self.access = leaf["access"]
		else:
			self.access = None
		if "name" in leafkeys:
			self.name = leaf["name"]
		else:
			self.name = None
		if "display" in leafkeys:
			self.display = leaf["display"]
		else:
			self.display = None
		if "fancy" in leafkeys:
			self.fancy = leaf["fancy"]
		else:
			self.fancy = None
		if "fancy_data" in leafkeys:
			self.fancy_data = leaf["fancy_data"]
		else:
			self.fancy_data = None
		if "description" in leafkeys:
			self.description = leaf["description"]
		else:
			self.description = None
		if "lo" in leafkeys:
			self.lo = leaf["lo"]
		else:
			self.lo = None
		if "hi" in leafkeys:
			self.hi = leaf["hi"]
		else:
			self.hi = None

		#old_leaves = []
		#new_leaves = []
		#if not (self.fancy_data is None):
		#	if (self.fancy == "ATUI_BITFIELD"):
		#		print(leaf.fancy_data)
		#		old_leaves = self.fancy_data
		#		self.fancy_data = new_leaves
		#	elif (self.fancy == "ATUI_DYNARRAY"):
		#		if ("pattern" in self.fancy_data):
		#			old_leaves = self.fancy_data["pattern"]
		#			self.fancy_data = self.fancy_data.copy()
		#			self.fancy_data["pattern"] = new_leaves
		#for leaf in old_leaves:
		#	new_leaves.append(atui_leaf(leaf))


class atui_branch:
	c_prefix:str
	c_type:str
	atomtree:str
	name:str
	description:dict
	leaves:list

	def copy(self):
		return copy.copy(self)

	def __init__(self, branch:dict):
		branchkeys = set(branch)

		if "c_prefix" in branchkeys:
			self.c_prefix = branch["c_prefix"]
		else:
			self.c_prefix = None
		if "c_type" in branchkeys:
			self.c_type = branch["c_type"]
		else:
			self.c_type = None
		if "atomtree" in branchkeys:
			self.atomtree = branch["atomtree"]
		else:
			self.atomtree = None
		if "name" in branchkeys:
			self.name = branch["name"]
		else:
			self.name = None
		if "description" in branchkeys:
			self.description = branch["description"]
		else:
			self.description = None

		if "leaves" in branchkeys:
			self.leaves = []
			for leaf in branch["leaves"]:
				self.leaves.append(atui_leaf(leaf))
		else:
			self.leaves = None


def populate_branch_defaults(defaults:dict):
	default_leaf_types = set(("generic", "bitchild", "dynpattern"))
	leaves = {}
	if "leaf_defaults" in defaults:
		leaves = defaults["leaf_defaults"]
		for leaf in leaves:
			default_leaf_types.remove(leaf)
	else:
		defaults["leaf_defaults"] = leaves
	for name in default_leaf_types:
		leaves[name] = {}

	if not ("branch_defaults" in defaults):
		defaults["branch_defaults"] = {}

	classed_leaves = {}
	for leaf in leaves:
		classed_leaves[leaf] = atui_leaf(leaves[leaf])
	classed_defaults = {
		"branch_defaults": atui_branch(defaults["branch_defaults"]),
		"leaf_defaults": classed_leaves
	}
	return classed_defaults

def infer_leaf_data(defaults:dict, leaf_select:str, leaves:list):
	# infer missing data on a branche's leaves based on what already exists for
	# a leaf, and the global_defaults

	leaf_defaults = defaults["leaf_defaults"]
	leaf_default = leaf_defaults[leaf_select]

	for leaf in leaves:
		assert (not (leaf.name is None))

		if leaf.access is None:
			leaf.access = leaf_default.access
		if leaf.display is None:
			leaf.display = leaf_default.display
		if leaf.fancy is None:
			leaf.fancy = leaf_default.fancy
		if leaf.fancy_data is None:
			leaf.fancy_data = leaf_default.fancy_data
		if leaf.description is None:
			leaf.description = leaf_default.description
		if leaf.lo is None:
			leaf.lo = leaf_default.lo
		if leaf.hi is None:
			leaf.hi = leaf_default.hi

		fancy_data = None
		old_default = None
		child_leaf = None
		access = ""
		if leaf.fancy == "ATUI_BITFIELD":
			fancy_data = copy.copy(leaf.fancy_data)
			leaf.fancy_data = []
			for l in fancy_data:
				 leaf.fancy_data.append(atui_leaf(l))

			old_default = leaf_defaults["bitchild"]
			new_default = old_default.copy()
			leaf_defaults["bitchild"] = new_default
			new_default.access = leaf.access
			new_default.fancy = "_ATUI_BITCHILD"
			infer_leaf_data(defaults, "bitchild", leaf.fancy_data)

			leaf_defaults["bitchild"] = old_default
		elif leaf.fancy == "ATUI_DYNARRAY":
			fancy_data = copy.copy(leaf.fancy_data)
			pattern = []
			leaf.fancy_data["pattern"] = pattern
			for l in fancy_data["pattern"]:
				 pattern.append(atui_leaf(l))

			if not ("enum" in leaf.fancy_data):
				leaf.fancy_data["enum"] = "NULL"
			if leaf.access:
				access = leaf.access + "[0]" # direct array
			else:
				access = fancy_data["deferred"] + "[0][0]" # array of pointers

			old_default = leaf_defaults["dynpattern"]
			new_default = old_default.copy()
			leaf_defaults["dynpattern"] = new_default
			new_default.access = access
			infer_leaf_data(defaults, "dynpattern", pattern)

			leaf_defaults["dynpattern"] = old_default

		if (leaf.fancy in
				("ATUI_DYNARRAY", "ATUI_STRING","ATUI_INLINE","ATUI_PETIOLE")
				):
			if leaf.display not in ("ATUI_NODISPLAY", "ATUI_NAN"):
				leaf.display = "ATUI_NAN"


def infer_branch_data(defaults:dict, branch:atui_branch):
	# infer missing data on both the branch elements and all of its leaves,
	# based on what already exists for that branch, and the global_defaults

	branch_defaults = defaults["branch_defaults"]

	if branch.c_prefix is None:
		branch.c_prefix = branch_defaults.c_prefix
	if branch.atomtree is None:
		branch.atomtree = branch_defaults.atomtree
	if branch.description is None:
		branch.description = branch_defaults.description

	assert (not (branch.c_type is None))
	if branch.name is None:
		branch.name = branch.c_type

	if branch.leaves:
		infer_leaf_data(defaults, "generic", branch.leaves)

def description_to_text(description:dict, indent:str):
	if (description is None):
		return ""
	lang_type = ""
	languages = ("english",)
	descriptions = [None,]
	descr_index = 0
	for trans in description:
		descr_index = languages.index(trans["language"])
		descriptions[descr_index] = trans["text"]

	child_indent = indent + "\t"
	descr_template = (
indent + ".description = {\n"
+ "%s"
+ indent + "},\n"
	)

	des_entry_template = child_indent + "u8\"%s\",\n"
	des_null_entry_template = child_indent + "NULL,\n"

	descr_texts = ""
	for d in descriptions:
		if d:
			descr_texts += des_entry_template % d
		else:
			descr_texts += des_null_entry_template
	return descr_template % descr_texts


def leaves_to_text(leaves:list, indent:str):
	child_indent = indent + "\t"
	leaf_template = (
indent + "{\n"
+ child_indent + ".name = u8\"%s\",\n"
+ child_indent + ".origname = u8\"%s\",\n"
+ child_indent + ".varname = u8\"%s\",\n"
+ child_indent + ".type = (\n"
+ child_indent + "\t%s | %s\n"
+ child_indent + "\t| _PPATUI_LEAF_SIGNED(%s)\n"
+ child_indent + "\t| _PPATUI_LEAF_FRACTION(%s)\n"
+ child_indent + "),\n"
+ child_indent + ".num_bytes = _PPATUI_LEAF_SIGNED(%s),\n"
+ child_indent + ".array_size = 1,\n"
+ child_indent + ".fractional_bits = _PPATUI_LEAF_FIXED_FRACTION_BITS(%s),\n"
+ child_indent + ".total_bits = _PPATUI_LEAF_BITNESS(%s),\n"
+ child_indent + ".bitfield_hi = _PPATUI_LEAF_BITNESS(%s) - 1,\n"
+ child_indent + ".val = _PPATUI_NULLPTR(%s),\n"
+ "%s"
+ indent + "},\n"
)

	leaf_text_extra = "" # if there is any extra leaf elements
	access_var = ""
	leaves_text = ""

	for leaf in leaves:
		access_var = leaf.access
		if leaf.fancy in ("ATUI_NOFANCY", "ATUI_STRING"):
			leaf_text_extra = ""
		elif leaf.fancy == "ATUI_ENUM":
			leaf_text_extra = (
				child_indent + ".enum_options = &(PPATUI_ENUM_NAME(%s)),\n"
			)
			leaf_text_extra %= (leaf.fancy_data,)
		elif leaf.fancy == "ATUI_ARRAY":
			access_var = leaf.access + "[0]"
			leaf_text_extra = (
				child_indent + ".array_size = (sizeof(%s)/sizeof(%s)),\n"
			)
			leaf_text_extra %= (leaf.access, access_var)
		elif leaf.fancy == "ATUI_BITFIELD":
			leaf_text_extra = (
				child_indent + ".num_child_leaves = %u,\n"
			)
			leaf_text_extra %= (len(leaf.fancy_data),)
		elif leaf.fancy == "_ATUI_BITCHILD":
			leaf_text_extra = (
				child_indent + ".bitfield_hi = %s,\n"
				+ child_indent + ".bitfield_lo = %s,\n"
			)
			leaf_text_extra %= (leaf.hi, leaf.lo)
		elif leaf.fancy in ("ATUI_PETIOLE", "ATUI_INLINE"):
			leaf_text_extra = (
				child_indent + ".branch_bud = PPATUI_FUNC_NAME(%s),\n"
			)
			leaf_text_extra %= (leaf.fancy_data,)
		elif leaf.fancy == "ATUI_DYNARRAY":
			access_var = leaf.access + "[0]"
			leaf_text_extra = ""
			#leaf_text_extra = (
			#	child_indent + ".num_child_leaves = %u,\n"
			#	+ child_indent + ".child_leaves = (const atui_leaf[]){\n%s\n"
			#	+ child_indent + "},\n"
			#)
			#leaf_text_extra %= (
			#	len(leaf.fancy_data["pattern"]),
			#	leaves_to_text(leaf.fancy_data["pattern"], child_indent)
			#)
		else:
			assert 0, leaf.fancy

		leaf_text_extra += description_to_text(leaf.description, child_indent)

		leaves_text += leaf_template % (
			leaf.name, leaf.name, leaf.access,
			leaf.display, leaf.fancy, access_var, access_var,
			access_var, access_var, access_var, access_var, access_var,
			leaf_text_extra
		)
		if leaf.fancy == "ATUI_BITFIELD":
			leaves_text += leaves_to_text(leaf.fancy_data, child_indent)
	return leaves_text
		

def leaf_to_dynbounds(leaf:atui_leaf, indent:str):
	child_indent = indent + "\t"
	bounds_template = (
indent + "{\n"
+ child_indent + ".deferred_start_array = %s,\n"
+ child_indent + ".element_size = sizeof(%s[0]),\n"
+ child_indent + ".dynarray_length = %s,\n"
+ child_indent + ".numleaves = %u,\n"
+ child_indent + ".enum_taglist = _PPATUI_NULLPTR(PPATUI_ENUM_NAME(%s)),\n"
+ indent + "},\n"
)
	access = ""
	if leaf.access:
		access = leaf.access # direct array
	else:
		access = fancy_data["deferred"] + "[0]" # array of pointers
	return bounds_template % (
		leaf.fancy_data["deferred"],
		access,
		leaf.fancy_data["count"],
		len(leaf.fancy_data["pattern"]),
		leaf.fancy_data["enum"],
	)

def branches_to_c(atui_data:dict):
	assert(atui_data["class"] == "branch")
	assert(type(atui_data["branches"]) is list)

	branches = []
	defaults = None
	defaults = populate_branch_defaults(atui_data["global_default"])
	for bd in atui_data["branches"]:
		branch = atui_branch(bd)
		infer_branch_data(defaults, branch)
		branches.append(branch)

	cfile_start = """\
/* autogenerated with ppatui.py. Do not edit */

#include "atomtree.h"
#include "atui.h"
"""
# These arrays need to be in a function to handle the bios-> and atomtree->
# everywhere. trying to globalise the vars gets annoying real fast.
	branch_template = """
PPATUI_HEADERIFY(%s) {
	const %s %s* const bios = args->suggestbios;
	const struct %s* const atomtree = args->atomtree;

	const atui_leaf leaves_initial[] = {
%s
	};
	const atui_leaf dynarray_patterns[] = {
%s
	};
	const struct dynarray_bounds dynarray_boundaries[] = {
%s
	};
	const struct atui_branch_data branch_embryo = {
		.varname = u8"%s",

		.leaves_initial = leaves_initial,
		.dynarray_patterns = dynarray_patterns,
		.dynarray_boundaries = dynarray_boundaries,
		.num_leaves_initial = sizeof(leaves_initial)/sizeof(atui_leaf),
		.num_dynarray_sets = (
			sizeof(dynarray_boundaries)/sizeof(struct dynarray_bounds)
		),
		.num_inline_initial = %u,
		.num_branches_initial = %u,
	};

	static_assert(sizeof(u8"%s") <= sizeof(((atui_branch*)0)->name));

	/* some things are kept in uint8_t */
	static_assert((sizeof(leaves_initial)/sizeof(atui_leaf)) < 255);

	return atui_branch_allocator(&branch_embryo, args);
}
"""

	dynarray_patterns_text = ""
	dynarray_bounds_text = ""
	num_inline = 0
	num_petiole = 0

	out_text = cfile_start
	for branch in branches:
		dynarray_patterns_text = dynarray_bounds_text = ""
		num_inline = 0
		num_petiole = 0
		for leaf in branch.leaves:
			if leaf.fancy == "ATUI_DYNARRAY":
				dynarray_patterns_text += leaves_to_text(
					leaf.fancy_data["pattern"], "\t\t"
				)
				dynarray_bounds_text += leaf_to_dynbounds(leaf, "\t\t")
			elif leaf.fancy == "ATUI_INLINE":
				num_inline += 1
			elif leaf.fancy == "ATUI_PETIOLE":
				num_petiole += 1
				
		out_text += branch_template % (
			branch.name, branch.c_prefix, branch.c_type, branch.atomtree,
			leaves_to_text(branch.leaves, "\t\t"),
			dynarray_patterns_text, dynarray_bounds_text,
			branch.name, num_inline, num_petiole, # embryo
			branch.name, # assert
		)

	return out_text



def get_mode(atui_data:dict):
	assert("class" in atui_data)
	match (atui_data["class"]):
		case "branch": return branches_to_c
		case "enum": return enum_to_h
		case _: assert 0

def main(argc:int, argv:list):
	if (argc != 3):
		print("usage: %s input.json5 output.c" % argv[0])
		return 1

	atui_data = {}
	with open(argv[1], 'r', encoding="utf-8") as f:
		atui_data = json5.load(f)

	mode_func = get_mode(atui_data)
	output_text = mode_func(atui_data)

	with open(argv[2], 'w', encoding="utf-8") as f:
		f.write(output_text)

if (__name__ == "__main__"):
	sys.exit(main(len(sys.argv), sys.argv))
